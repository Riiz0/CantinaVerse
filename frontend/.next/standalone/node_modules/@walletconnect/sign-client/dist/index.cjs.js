"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var N=require("@walletconnect/core"),k=require("@walletconnect/logger"),ae=require("@walletconnect/types"),i=require("@walletconnect/utils"),ce=require("events"),E=require("@walletconnect/time"),g=require("@walletconnect/jsonrpc-utils");function qe(m){return m&&typeof m=="object"&&"default"in m?m:{default:m}}var ve=qe(ce);const ee="wc",te=2,se="client",j=`${ee}@${te}:${se}:`,Y={name:se,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.com"},Te={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire",session_authenticate:"session_authenticate",session_request_expire:"session_request_expire"},Pe={database:":memory:"},ie="WALLETCONNECT_DEEPLINK_CHOICE",Oe={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Ae="history",Ve="0.3",le="proposal",Ce=E.THIRTY_DAYS,he="Proposal expired",pe="session",V=E.SEVEN_DAYS,de="engine",S={wc_sessionPropose:{req:{ttl:E.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:E.FIVE_MINUTES,prompt:!1,tag:1101},reject:{ttl:E.FIVE_MINUTES,prompt:!1,tag:1120},autoReject:{ttl:E.FIVE_MINUTES,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:E.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:E.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:E.ONE_DAY,prompt:!1,tag:1104},res:{ttl:E.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:E.ONE_DAY,prompt:!1,tag:1106},res:{ttl:E.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:E.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:E.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:E.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:E.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:E.ONE_DAY,prompt:!1,tag:1112},res:{ttl:E.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:E.ONE_DAY,prompt:!1,tag:1114},res:{ttl:E.ONE_DAY,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:E.ONE_HOUR,prompt:!0,tag:1116},res:{ttl:E.ONE_HOUR,prompt:!1,tag:1117},reject:{ttl:E.FIVE_MINUTES,prompt:!1,tag:1118},autoReject:{ttl:E.FIVE_MINUTES,prompt:!1,tag:1119}}},Q={min:E.FIVE_MINUTES,max:E.SEVEN_DAYS},A={idle:"IDLE",active:"ACTIVE"},ue="request",ge=["wc_sessionPropose","wc_sessionRequest","wc_authRequest","wc_sessionAuthenticate"],Ee="wc",De=1.5,we="auth",ye="authKeys",me="pairingTopics",Ie="requests",U=`${Ee}@${1.5}:${we}:`,$=`${U}:PUB_KEY`;var xe=Object.defineProperty,Me=Object.defineProperties,be=Object.getOwnPropertyDescriptors,Se=Object.getOwnPropertySymbols,Le=Object.prototype.hasOwnProperty,Ue=Object.prototype.propertyIsEnumerable,Re=(m,o,t)=>o in m?xe(m,o,{enumerable:!0,configurable:!0,writable:!0,value:t}):m[o]=t,I=(m,o)=>{for(var t in o||(o={}))Le.call(o,t)&&Re(m,t,o[t]);if(Se)for(var t of Se(o))Ue.call(o,t)&&Re(m,t,o[t]);return m},C=(m,o)=>Me(m,be(o));class $e extends ae.IEngine{constructor(o){super(o),this.name=de,this.events=new ve.default,this.initialized=!1,this.requestQueue={state:A.idle,queue:[]},this.sessionRequestQueue={state:A.idle,queue:[]},this.requestQueueDelay=E.ONE_SECOND,this.expectedPairingMethodMap=new Map,this.recentlyDeletedMap=new Map,this.recentlyDeletedLimit=200,this.relayMessageCache=[],this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),this.client.core.pairing.register({methods:Object.keys(S)}),this.initialized=!0,setTimeout(()=>{this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},E.toMiliseconds(this.requestQueueDelay)))},this.connect=async t=>{await this.isInitialized();const e=C(I({},t),{requiredNamespaces:t.requiredNamespaces||{},optionalNamespaces:t.optionalNamespaces||{}});await this.isValidConnect(e);const{pairingTopic:s,requiredNamespaces:r,optionalNamespaces:n,sessionProperties:a,relays:c}=e;let l=s,h,d=!1;try{l&&(d=this.client.core.pairing.pairings.get(l).active)}catch(v){throw this.client.logger.error(`connect() -> pairing.get(${l}) failed`),v}if(!l||!d){const{topic:v,uri:T}=await this.client.core.pairing.create();l=v,h=T}if(!l){const{message:v}=i.getInternalError("NO_MATCHING_KEY",`connect() pairing topic: ${l}`);throw new Error(v)}const u=await this.client.core.crypto.generateKeyPair(),p=S.wc_sessionPropose.req.ttl||E.FIVE_MINUTES,w=i.calcExpiry(p),y=I({requiredNamespaces:r,optionalNamespaces:n,relays:c??[{protocol:N.RELAYER_DEFAULT_PROTOCOL}],proposer:{publicKey:u,metadata:this.client.metadata},expiryTimestamp:w,pairingTopic:l},a&&{sessionProperties:a}),{reject:R,resolve:P,done:_}=i.createDelayedPromise(p,he);this.events.once(i.engineEvent("session_connect"),async({error:v,session:T})=>{if(v)R(v);else if(T){T.self.publicKey=u;const M=C(I({},T),{pairingTopic:y.pairingTopic,requiredNamespaces:y.requiredNamespaces,optionalNamespaces:y.optionalNamespaces});await this.client.session.set(T.topic,M),await this.setExpiry(T.topic,T.expiry),l&&await this.client.core.pairing.updateMetadata({topic:l,metadata:T.peer.metadata}),this.cleanupDuplicatePairings(M),P(M)}});const q=await this.sendRequest({topic:l,method:"wc_sessionPropose",params:y,throwOnFailedPublish:!0});return await this.setProposal(q,I({id:q},y)),{uri:h,approval:_}},this.pair=async t=>{await this.isInitialized();try{return await this.client.core.pairing.pair(t)}catch(e){throw this.client.logger.error("pair() failed"),e}},this.approve=async t=>{await this.isInitialized();try{await this.isValidApprove(t)}catch(_){throw this.client.logger.error("approve() -> isValidApprove() failed"),_}const{id:e,relayProtocol:s,namespaces:r,sessionProperties:n,sessionConfig:a}=t;let c;try{c=this.client.proposal.get(e)}catch(_){throw this.client.logger.error(`approve() -> proposal.get(${e}) failed`),_}const{pairingTopic:l,proposer:h,requiredNamespaces:d,optionalNamespaces:u}=c,p=await this.client.core.crypto.generateKeyPair(),w=h.publicKey,y=await this.client.core.crypto.generateSharedKey(p,w),R=I(I({relay:{protocol:s??"irn"},namespaces:r,controller:{publicKey:p,metadata:this.client.metadata},expiry:i.calcExpiry(V)},n&&{sessionProperties:n}),a&&{sessionConfig:a});await this.client.core.relayer.subscribe(y);const P=C(I({},R),{topic:y,requiredNamespaces:d,optionalNamespaces:u,pairingTopic:l,acknowledged:!1,self:R.controller,peer:{publicKey:h.publicKey,metadata:h.metadata},controller:p});await this.client.session.set(y,P);try{await this.sendResult({id:e,topic:l,result:{relay:{protocol:s??"irn"},responderPublicKey:p},throwOnFailedPublish:!0}),await this.sendRequest({topic:y,method:"wc_sessionSettle",params:R,throwOnFailedPublish:!0})}catch(_){throw this.client.logger.error(_),this.client.session.delete(y,i.getSdkError("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(y),_}return await this.client.core.pairing.updateMetadata({topic:l,metadata:h.metadata}),await this.client.proposal.delete(e,i.getSdkError("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:l}),await this.setExpiry(y,i.calcExpiry(V)),{topic:y,acknowledged:()=>new Promise(_=>setTimeout(()=>_(this.client.session.get(y)),500))}},this.reject=async t=>{await this.isInitialized();try{await this.isValidReject(t)}catch(n){throw this.client.logger.error("reject() -> isValidReject() failed"),n}const{id:e,reason:s}=t;let r;try{r=this.client.proposal.get(e).pairingTopic}catch(n){throw this.client.logger.error(`reject() -> proposal.get(${e}) failed`),n}r&&(await this.sendError({id:e,topic:r,error:s,rpcOpts:S.wc_sessionPropose.reject}),await this.client.proposal.delete(e,i.getSdkError("USER_DISCONNECTED")))},this.update=async t=>{await this.isInitialized();try{await this.isValidUpdate(t)}catch(d){throw this.client.logger.error("update() -> isValidUpdate() failed"),d}const{topic:e,namespaces:s}=t,{done:r,resolve:n,reject:a}=i.createDelayedPromise(),c=g.payloadId(),l=g.getBigIntRpcId().toString(),h=this.client.session.get(e).namespaces;return this.events.once(i.engineEvent("session_update",c),({error:d})=>{d?a(d):n()}),await this.client.session.update(e,{namespaces:s}),await this.sendRequest({topic:e,method:"wc_sessionUpdate",params:{namespaces:s},throwOnFailedPublish:!0,clientRpcId:c,relayRpcId:l}).catch(d=>{this.client.logger.error(d),this.client.session.update(e,{namespaces:h}),a(d)}),{acknowledged:r}},this.extend=async t=>{await this.isInitialized();try{await this.isValidExtend(t)}catch(c){throw this.client.logger.error("extend() -> isValidExtend() failed"),c}const{topic:e}=t,s=g.payloadId(),{done:r,resolve:n,reject:a}=i.createDelayedPromise();return this.events.once(i.engineEvent("session_extend",s),({error:c})=>{c?a(c):n()}),await this.setExpiry(e,i.calcExpiry(V)),this.sendRequest({topic:e,method:"wc_sessionExtend",params:{},clientRpcId:s,throwOnFailedPublish:!0}).catch(c=>{a(c)}),{acknowledged:r}},this.request=async t=>{await this.isInitialized();try{await this.isValidRequest(t)}catch(p){throw this.client.logger.error("request() -> isValidRequest() failed"),p}const{chainId:e,request:s,topic:r,expiry:n=S.wc_sessionRequest.req.ttl}=t,a=this.client.session.get(r),c=g.payloadId(),l=g.getBigIntRpcId().toString(),{done:h,resolve:d,reject:u}=i.createDelayedPromise(n,"Request expired. Please try again.");return this.events.once(i.engineEvent("session_request",c),({error:p,result:w})=>{p?u(p):d(w)}),await Promise.all([new Promise(async p=>{await this.sendRequest({clientRpcId:c,relayRpcId:l,topic:r,method:"wc_sessionRequest",params:{request:C(I({},s),{expiryTimestamp:i.calcExpiry(n)}),chainId:e},expiry:n,throwOnFailedPublish:!0}).catch(w=>u(w)),this.client.events.emit("session_request_sent",{topic:r,request:s,chainId:e,id:c}),p()}),new Promise(async p=>{var w;if(!((w=a.sessionConfig)!=null&&w.disableDeepLink)){const y=await i.getDeepLink(this.client.core.storage,ie);i.handleDeeplinkRedirect({id:c,topic:r,wcDeepLink:y})}p()}),h()]).then(p=>p[2])},this.respond=async t=>{await this.isInitialized(),await this.isValidRespond(t);const{topic:e,response:s}=t,{id:r}=s;g.isJsonRpcResult(s)?await this.sendResult({id:r,topic:e,result:s.result,throwOnFailedPublish:!0}):g.isJsonRpcError(s)&&await this.sendError({id:r,topic:e,error:s.error}),this.cleanupAfterResponse(t)},this.ping=async t=>{await this.isInitialized();try{await this.isValidPing(t)}catch(s){throw this.client.logger.error("ping() -> isValidPing() failed"),s}const{topic:e}=t;if(this.client.session.keys.includes(e)){const s=g.payloadId(),r=g.getBigIntRpcId().toString(),{done:n,resolve:a,reject:c}=i.createDelayedPromise();this.events.once(i.engineEvent("session_ping",s),({error:l})=>{l?c(l):a()}),await Promise.all([this.sendRequest({topic:e,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:s,relayRpcId:r}),n()])}else this.client.core.pairing.pairings.keys.includes(e)&&await this.client.core.pairing.ping({topic:e})},this.emit=async t=>{await this.isInitialized(),await this.isValidEmit(t);const{topic:e,event:s,chainId:r}=t,n=g.getBigIntRpcId().toString();await this.sendRequest({topic:e,method:"wc_sessionEvent",params:{event:s,chainId:r},throwOnFailedPublish:!0,relayRpcId:n})},this.disconnect=async t=>{await this.isInitialized(),await this.isValidDisconnect(t);const{topic:e}=t;if(this.client.session.keys.includes(e))await this.sendRequest({topic:e,method:"wc_sessionDelete",params:i.getSdkError("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:e,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(e))await this.client.core.pairing.disconnect({topic:e});else{const{message:s}=i.getInternalError("MISMATCHED_TOPIC",`Session or pairing topic not found: ${e}`);throw new Error(s)}},this.find=t=>(this.isInitialized(),this.client.session.getAll().filter(e=>i.isSessionCompatible(e,t))),this.getPendingSessionRequests=()=>this.client.pendingRequest.getAll(),this.authenticate=async t=>{this.isInitialized(),this.isValidAuthenticate(t);const{chains:e,statement:s="",uri:r,domain:n,nonce:a,type:c,exp:l,nbf:h,methods:d=[],expiry:u}=t,p=[...t.resources||[]],{topic:w,uri:y}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"]});this.client.logger.info({message:"Generated new pairing",pairing:{topic:w,uri:y}});const R=await this.client.core.crypto.generateKeyPair(),P=i.hashKey(R);if(await Promise.all([this.client.auth.authKeys.set($,{responseTopic:P,publicKey:R}),this.client.auth.pairingTopics.set(P,{topic:P,pairingTopic:w})]),await this.client.core.relayer.subscribe(P),this.client.logger.info(`sending request to new pairing topic: ${w}`),d.length>0){const{namespace:O}=i.parseChainId(e[0]);let f=i.createEncodedRecap(O,"request",d);i.getRecapFromResources(p)&&(f=i.mergeEncodedRecaps(f,p.pop())),p.push(f)}const _=u&&u>S.wc_sessionAuthenticate.req.ttl?u:S.wc_sessionAuthenticate.req.ttl,q={authPayload:{type:c??"caip122",chains:e,statement:s,aud:r,domain:n,version:"1",nonce:a,iat:new Date().toISOString(),exp:l,nbf:h,resources:p},requester:{publicKey:R,metadata:this.client.metadata},expiryTimestamp:i.calcExpiry(_)},v={eip155:{chains:e,methods:[...new Set(["personal_sign",...d])],events:["chainChanged","accountsChanged"]}},T={requiredNamespaces:{},optionalNamespaces:v,relays:[{protocol:"irn"}],pairingTopic:w,proposer:{publicKey:R,metadata:this.client.metadata},expiryTimestamp:i.calcExpiry(S.wc_sessionPropose.req.ttl)},{done:M,resolve:re,reject:X}=i.createDelayedPromise(_,"Request expired"),K=async({error:O,session:f})=>{if(this.events.off(i.engineEvent("session_request",D),J),O)X(O);else if(f){f.self.publicKey=R,await this.client.session.set(f.topic,f),await this.setExpiry(f.topic,f.expiry),w&&await this.client.core.pairing.updateMetadata({topic:w,metadata:f.peer.metadata});const x=this.client.session.get(f.topic);await this.deleteProposal(b),re({session:x})}},J=async O=>{if(await this.deletePendingAuthRequest(D,{message:"fulfilled",code:0}),O.error){const L=i.getSdkError("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return O.error.code===L.code?void 0:(this.events.off(i.engineEvent("session_connect"),K),X(O.error.message))}await this.deleteProposal(b),this.events.off(i.engineEvent("session_connect"),K);const{cacaos:f,responder:x}=O.result,z=[],ne=[];for(const L of f){await i.validateSignedCacao({cacao:L,projectId:this.client.core.projectId})||(this.client.logger.error(L,"Signature verification failed"),X(i.getSdkError("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:B}=L,W=i.getRecapFromResources(B.resources),oe=[i.getNamespacedDidChainId(B.iss)],fe=i.getDidAddress(B.iss);if(W){const Z=i.getMethodsFromRecap(W),Ne=i.getChainsFromRecap(W);z.push(...Z),oe.push(...Ne)}for(const Z of oe)ne.push(`${Z}:${fe}`)}const G=await this.client.core.crypto.generateSharedKey(R,x.publicKey);let F;z.length>0&&(F={topic:G,acknowledged:!0,self:{publicKey:R,metadata:this.client.metadata},peer:x,controller:x.publicKey,expiry:i.calcExpiry(V),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:w,namespaces:i.buildNamespacesFromAuth([...new Set(z)],[...new Set(ne)])},await this.client.core.relayer.subscribe(G),await this.client.session.set(G,F),w&&await this.client.core.pairing.updateMetadata({topic:w,metadata:x.metadata}),F=this.client.session.get(G)),re({auths:f,session:F})},D=g.payloadId(),b=g.payloadId();this.events.once(i.engineEvent("session_connect"),K),this.events.once(i.engineEvent("session_request",D),J);try{await Promise.all([this.sendRequest({topic:w,method:"wc_sessionAuthenticate",params:q,expiry:t.expiry,throwOnFailedPublish:!0,clientRpcId:D}),this.sendRequest({topic:w,method:"wc_sessionPropose",params:T,expiry:S.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:b})])}catch(O){throw this.events.off(i.engineEvent("session_connect"),K),this.events.off(i.engineEvent("session_request",D),J),O}return await this.setProposal(b,I({id:b},T)),await this.setAuthRequest(D,{request:C(I({},q),{verifyContext:{}}),pairingTopic:w}),{uri:y,response:M}},this.approveSessionAuthenticate=async t=>{this.isInitialized();const{id:e,auths:s}=t,r=this.getPendingAuthRequest(e);if(!r)throw new Error(`Could not find pending auth request with id ${e}`);const n=r.requester.publicKey,a=await this.client.core.crypto.generateKeyPair(),c=i.hashKey(n),l={type:i.TYPE_1,receiverPublicKey:n,senderPublicKey:a},h=[],d=[];for(const w of s){if(!await i.validateSignedCacao({cacao:w,projectId:this.client.core.projectId})){const q=i.getSdkError("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:e,topic:c,error:q,encodeOpts:l}),new Error(q.message)}const{p:y}=w,R=i.getRecapFromResources(y.resources),P=[i.getNamespacedDidChainId(y.iss)],_=i.getDidAddress(y.iss);if(R){const q=i.getMethodsFromRecap(R),v=i.getChainsFromRecap(R);h.push(...q),P.push(...v)}for(const q of P)d.push(`${q}:${_}`)}const u=await this.client.core.crypto.generateSharedKey(a,n);let p;return h?.length>0&&(p={topic:u,acknowledged:!0,self:{publicKey:a,metadata:this.client.metadata},peer:{publicKey:n,metadata:r.requester.metadata},controller:n,expiry:i.calcExpiry(V),authentication:s,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:r.pairingTopic,namespaces:i.buildNamespacesFromAuth([...new Set(h)],[...new Set(d)])},await this.client.core.relayer.subscribe(u),await this.client.session.set(u,p),await this.client.core.pairing.updateMetadata({topic:r.pairingTopic,metadata:r.requester.metadata})),await this.sendResult({topic:c,id:e,result:{cacaos:s,responder:{publicKey:a,metadata:this.client.metadata}},encodeOpts:l,throwOnFailedPublish:!0}),await this.client.auth.requests.delete(e,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:r.pairingTopic}),{session:p}},this.rejectSessionAuthenticate=async t=>{await this.isInitialized();const{id:e,reason:s}=t,r=this.getPendingAuthRequest(e);if(!r)throw new Error(`Could not find pending auth request with id ${e}`);const n=r.requester.publicKey,a=await this.client.core.crypto.generateKeyPair(),c=i.hashKey(n),l={type:i.TYPE_1,receiverPublicKey:n,senderPublicKey:a};await this.sendError({id:e,topic:c,error:s,encodeOpts:l,rpcOpts:S.wc_sessionAuthenticate.reject}),await this.client.auth.requests.delete(e,{message:"rejected",code:0}),await this.client.proposal.delete(e,i.getSdkError("USER_DISCONNECTED"))},this.formatAuthMessage=t=>{this.isInitialized();const{request:e,iss:s}=t;return i.formatMessage(e,s)},this.processRelayMessageCache=()=>{setTimeout(async()=>{if(this.relayMessageCache.length!==0)for(;this.relayMessageCache.length>0;)try{const t=this.relayMessageCache.shift();t&&await this.onRelayMessage(t)}catch(t){this.client.logger.error(t)}},50)},this.cleanupDuplicatePairings=async t=>{if(t.pairingTopic)try{const e=this.client.core.pairing.pairings.get(t.pairingTopic),s=this.client.core.pairing.pairings.getAll().filter(r=>{var n,a;return((n=r.peerMetadata)==null?void 0:n.url)&&((a=r.peerMetadata)==null?void 0:a.url)===t.peer.metadata.url&&r.topic&&r.topic!==e.topic});if(s.length===0)return;this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`),await Promise.all(s.map(r=>this.client.core.pairing.disconnect({topic:r.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(e){this.client.logger.error(e)}},this.deleteSession=async t=>{var e;const{topic:s,expirerHasDeleted:r=!1,emitEvent:n=!0,id:a=0}=t,{self:c}=this.client.session.get(s);await this.client.core.relayer.unsubscribe(s),await this.client.session.delete(s,i.getSdkError("USER_DISCONNECTED")),this.addToRecentlyDeleted(s,"session"),this.client.core.crypto.keychain.has(c.publicKey)&&await this.client.core.crypto.deleteKeyPair(c.publicKey),this.client.core.crypto.keychain.has(s)&&await this.client.core.crypto.deleteSymKey(s),r||this.client.core.expirer.del(s),this.client.core.storage.removeItem(ie).catch(l=>this.client.logger.warn(l)),this.getPendingSessionRequests().forEach(l=>{l.topic===s&&this.deletePendingSessionRequest(l.id,i.getSdkError("USER_DISCONNECTED"))}),s===((e=this.sessionRequestQueue.queue[0])==null?void 0:e.topic)&&(this.sessionRequestQueue.state=A.idle),n&&this.client.events.emit("session_delete",{id:a,topic:s})},this.deleteProposal=async(t,e)=>{await Promise.all([this.client.proposal.delete(t,i.getSdkError("USER_DISCONNECTED")),e?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"proposal")},this.deletePendingSessionRequest=async(t,e,s=!1)=>{await Promise.all([this.client.pendingRequest.delete(t,e),s?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(r=>r.id!==t),s&&(this.sessionRequestQueue.state=A.idle,this.client.events.emit("session_request_expire",{id:t}))},this.deletePendingAuthRequest=async(t,e,s=!1)=>{await Promise.all([this.client.auth.requests.delete(t,e),s?Promise.resolve():this.client.core.expirer.del(t)])},this.setExpiry=async(t,e)=>{this.client.session.keys.includes(t)&&(this.client.core.expirer.set(t,e),await this.client.session.update(t,{expiry:e}))},this.setProposal=async(t,e)=>{this.client.core.expirer.set(t,i.calcExpiry(S.wc_sessionPropose.req.ttl)),await this.client.proposal.set(t,e)},this.setAuthRequest=async(t,e)=>{const{request:s,pairingTopic:r}=e;this.client.core.expirer.set(t,s.expiryTimestamp),await this.client.auth.requests.set(t,{authPayload:s.authPayload,requester:s.requester,expiryTimestamp:s.expiryTimestamp,id:t,pairingTopic:r,verifyContext:s.verifyContext})},this.setPendingSessionRequest=async t=>{const{id:e,topic:s,params:r,verifyContext:n}=t,a=r.request.expiryTimestamp||i.calcExpiry(S.wc_sessionRequest.req.ttl);this.client.core.expirer.set(e,a),await this.client.pendingRequest.set(e,{id:e,topic:s,params:r,verifyContext:n})},this.sendRequest=async t=>{const{topic:e,method:s,params:r,expiry:n,relayRpcId:a,clientRpcId:c,throwOnFailedPublish:l}=t,h=g.formatJsonRpcRequest(s,r,c);if(i.isBrowser()&&ge.includes(s)){const p=i.hashMessage(JSON.stringify(h));this.client.core.verify.register({attestationId:p})}let d;try{d=await this.client.core.crypto.encode(e,h)}catch(p){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${e} failed`),p}const u=S[s].req;return n&&(u.ttl=n),a&&(u.id=a),this.client.core.history.set(e,h),l?(u.internal=C(I({},u.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(e,d,u)):this.client.core.relayer.publish(e,d,u).catch(p=>this.client.logger.error(p)),h.id},this.sendResult=async t=>{const{id:e,topic:s,result:r,throwOnFailedPublish:n,encodeOpts:a}=t,c=g.formatJsonRpcResult(e,r);let l;try{l=await this.client.core.crypto.encode(s,c,a)}catch(u){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`),u}let h;try{h=await this.client.core.history.get(s,e)}catch(u){throw this.client.logger.error(`sendResult() -> history.get(${s}, ${e}) failed`),u}const d=S[h.request.method].res;n?(d.internal=C(I({},d.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(s,l,d)):this.client.core.relayer.publish(s,l,d).catch(u=>this.client.logger.error(u)),await this.client.core.history.resolve(c)},this.sendError=async t=>{const{id:e,topic:s,error:r,encodeOpts:n,rpcOpts:a}=t,c=g.formatJsonRpcError(e,r);let l;try{l=await this.client.core.crypto.encode(s,c,n)}catch(u){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`),u}let h;try{h=await this.client.core.history.get(s,e)}catch(u){throw this.client.logger.error(`sendError() -> history.get(${s}, ${e}) failed`),u}const d=a||S[h.request.method].res;this.client.core.relayer.publish(s,l,d),await this.client.core.history.resolve(c)},this.cleanup=async()=>{const t=[],e=[];this.client.session.getAll().forEach(s=>{let r=!1;i.isExpired(s.expiry)&&(r=!0),this.client.core.crypto.keychain.has(s.topic)||(r=!0),r&&t.push(s.topic)}),this.client.proposal.getAll().forEach(s=>{i.isExpired(s.expiryTimestamp)&&e.push(s.id)}),await Promise.all([...t.map(s=>this.deleteSession({topic:s})),...e.map(s=>this.deleteProposal(s))])},this.onRelayEventRequest=async t=>{this.requestQueue.queue.push(t),await this.processRequestsQueue()},this.processRequestsQueue=async()=>{if(this.requestQueue.state===A.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=A.active;const t=this.requestQueue.queue.shift();if(t)try{await this.processRequest(t)}catch(e){this.client.logger.warn(e)}}this.requestQueue.state=A.idle},this.processRequest=async t=>{const{topic:e,payload:s}=t,r=s.method;if(!this.shouldIgnorePairingRequest({topic:e,requestMethod:r}))switch(r){case"wc_sessionPropose":return await this.onSessionProposeRequest(e,s);case"wc_sessionSettle":return await this.onSessionSettleRequest(e,s);case"wc_sessionUpdate":return await this.onSessionUpdateRequest(e,s);case"wc_sessionExtend":return await this.onSessionExtendRequest(e,s);case"wc_sessionPing":return await this.onSessionPingRequest(e,s);case"wc_sessionDelete":return await this.onSessionDeleteRequest(e,s);case"wc_sessionRequest":return await this.onSessionRequest(e,s);case"wc_sessionEvent":return await this.onSessionEventRequest(e,s);case"wc_sessionAuthenticate":return await this.onSessionAuthenticateRequest(e,s);default:return this.client.logger.info(`Unsupported request method ${r}`)}},this.onRelayEventResponse=async t=>{const{topic:e,payload:s}=t,r=(await this.client.core.history.get(e,s.id)).request.method;switch(r){case"wc_sessionPropose":return this.onSessionProposeResponse(e,s);case"wc_sessionSettle":return this.onSessionSettleResponse(e,s);case"wc_sessionUpdate":return this.onSessionUpdateResponse(e,s);case"wc_sessionExtend":return this.onSessionExtendResponse(e,s);case"wc_sessionPing":return this.onSessionPingResponse(e,s);case"wc_sessionRequest":return this.onSessionRequestResponse(e,s);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(e,s);default:return this.client.logger.info(`Unsupported response method ${r}`)}},this.onRelayEventUnknownPayload=t=>{const{topic:e}=t,{message:s}=i.getInternalError("MISSING_OR_INVALID",`Decoded payload on topic ${e} is not identifiable as a JSON-RPC request or a response.`);throw new Error(s)},this.shouldIgnorePairingRequest=t=>{const{topic:e,requestMethod:s}=t,r=this.expectedPairingMethodMap.get(e);return!r||r.includes(s)?!1:!!(r.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)},this.onSessionProposeRequest=async(t,e)=>{const{params:s,id:r}=e;try{this.isValidConnect(I({},e.params));const n=s.expiryTimestamp||i.calcExpiry(S.wc_sessionPropose.req.ttl),a=I({id:r,pairingTopic:t,expiryTimestamp:n},s);await this.setProposal(r,a);const c=i.hashMessage(JSON.stringify(e)),l=await this.getVerifyContext(c,a.proposer.metadata);this.client.events.emit("session_proposal",{id:r,params:a,verifyContext:l})}catch(n){await this.sendError({id:r,topic:t,error:n,rpcOpts:S.wc_sessionPropose.autoReject}),this.client.logger.error(n)}},this.onSessionProposeResponse=async(t,e)=>{const{id:s}=e;if(g.isJsonRpcResult(e)){const{result:r}=e;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:r});const n=this.client.proposal.get(s);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:n});const a=n.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:a});const c=r.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:c});const l=await this.client.core.crypto.generateSharedKey(a,c);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:l});const h=await this.client.core.relayer.subscribe(l);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:h}),await this.client.core.pairing.activate({topic:t})}else if(g.isJsonRpcError(e)){await this.client.proposal.delete(s,i.getSdkError("USER_DISCONNECTED"));const r=i.engineEvent("session_connect");if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners, 954`);this.events.emit(i.engineEvent("session_connect"),{error:e.error})}},this.onSessionSettleRequest=async(t,e)=>{const{id:s,params:r}=e;try{this.isValidSessionSettleRequest(r);const{relay:n,controller:a,expiry:c,namespaces:l,sessionProperties:h,sessionConfig:d}=e.params,u=I(I({topic:t,relay:n,expiry:c,namespaces:l,acknowledged:!0,pairingTopic:"",requiredNamespaces:{},optionalNamespaces:{},controller:a.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:a.publicKey,metadata:a.metadata}},h&&{sessionProperties:h}),d&&{sessionConfig:d});await this.sendResult({id:e.id,topic:t,result:!0,throwOnFailedPublish:!0});const p=i.engineEvent("session_connect");if(this.events.listenerCount(p)===0)throw new Error(`emitting ${p} without any listeners 997`);this.events.emit(i.engineEvent("session_connect"),{session:u})}catch(n){await this.sendError({id:s,topic:t,error:n}),this.client.logger.error(n)}},this.onSessionSettleResponse=async(t,e)=>{const{id:s}=e;g.isJsonRpcResult(e)?(await this.client.session.update(t,{acknowledged:!0}),this.events.emit(i.engineEvent("session_approve",s),{})):g.isJsonRpcError(e)&&(await this.client.session.delete(t,i.getSdkError("USER_DISCONNECTED")),this.events.emit(i.engineEvent("session_approve",s),{error:e.error}))},this.onSessionUpdateRequest=async(t,e)=>{const{params:s,id:r}=e;try{const n=`${t}_session_update`,a=i.MemoryStore.get(n);if(a&&this.isRequestOutOfSync(a,r)){this.client.logger.info(`Discarding out of sync request - ${r}`),this.sendError({id:r,topic:t,error:i.getSdkError("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(I({topic:t},s));try{i.MemoryStore.set(n,r),await this.client.session.update(t,{namespaces:s.namespaces}),await this.sendResult({id:r,topic:t,result:!0,throwOnFailedPublish:!0})}catch(c){throw i.MemoryStore.delete(n),c}this.client.events.emit("session_update",{id:r,topic:t,params:s})}catch(n){await this.sendError({id:r,topic:t,error:n}),this.client.logger.error(n)}},this.isRequestOutOfSync=(t,e)=>parseInt(e.toString().slice(0,-3))<=parseInt(t.toString().slice(0,-3)),this.onSessionUpdateResponse=(t,e)=>{const{id:s}=e,r=i.engineEvent("session_update",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);g.isJsonRpcResult(e)?this.events.emit(i.engineEvent("session_update",s),{}):g.isJsonRpcError(e)&&this.events.emit(i.engineEvent("session_update",s),{error:e.error})},this.onSessionExtendRequest=async(t,e)=>{const{id:s}=e;try{this.isValidExtend({topic:t}),await this.setExpiry(t,i.calcExpiry(V)),await this.sendResult({id:s,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:s,topic:t})}catch(r){await this.sendError({id:s,topic:t,error:r}),this.client.logger.error(r)}},this.onSessionExtendResponse=(t,e)=>{const{id:s}=e,r=i.engineEvent("session_extend",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);g.isJsonRpcResult(e)?this.events.emit(i.engineEvent("session_extend",s),{}):g.isJsonRpcError(e)&&this.events.emit(i.engineEvent("session_extend",s),{error:e.error})},this.onSessionPingRequest=async(t,e)=>{const{id:s}=e;try{this.isValidPing({topic:t}),await this.sendResult({id:s,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:s,topic:t})}catch(r){await this.sendError({id:s,topic:t,error:r}),this.client.logger.error(r)}},this.onSessionPingResponse=(t,e)=>{const{id:s}=e,r=i.engineEvent("session_ping",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);setTimeout(()=>{g.isJsonRpcResult(e)?this.events.emit(i.engineEvent("session_ping",s),{}):g.isJsonRpcError(e)&&this.events.emit(i.engineEvent("session_ping",s),{error:e.error})},500)},this.onSessionDeleteRequest=async(t,e)=>{const{id:s}=e;try{this.isValidDisconnect({topic:t,reason:e.params}),await Promise.all([new Promise(r=>{this.client.core.relayer.once(N.RELAYER_EVENTS.publish,async()=>{r(await this.deleteSession({topic:t,id:s}))})}),this.sendResult({id:s,topic:t,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:t,error:i.getSdkError("USER_DISCONNECTED")})])}catch(r){this.client.logger.error(r)}},this.onSessionRequest=async(t,e)=>{var s;const{id:r,params:n}=e;try{await this.isValidRequest(I({topic:t},n));const a=i.hashMessage(JSON.stringify(g.formatJsonRpcRequest("wc_sessionRequest",n,r))),c=this.client.session.get(t),l=await this.getVerifyContext(a,c.peer.metadata),h={id:r,topic:t,params:n,verifyContext:l};await this.setPendingSessionRequest(h),(s=this.client.signConfig)!=null&&s.disableRequestQueue?this.emitSessionRequest(h):(this.addSessionRequestToSessionRequestQueue(h),this.processSessionRequestQueue())}catch(a){await this.sendError({id:r,topic:t,error:a}),this.client.logger.error(a)}},this.onSessionRequestResponse=(t,e)=>{const{id:s}=e,r=i.engineEvent("session_request",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);g.isJsonRpcResult(e)?this.events.emit(i.engineEvent("session_request",s),{result:e.result}):g.isJsonRpcError(e)&&this.events.emit(i.engineEvent("session_request",s),{error:e.error})},this.onSessionEventRequest=async(t,e)=>{const{id:s,params:r}=e;try{const n=`${t}_session_event_${r.event.name}`,a=i.MemoryStore.get(n);if(a&&this.isRequestOutOfSync(a,s)){this.client.logger.info(`Discarding out of sync request - ${s}`);return}this.isValidEmit(I({topic:t},r)),this.client.events.emit("session_event",{id:s,topic:t,params:r}),i.MemoryStore.set(n,s)}catch(n){await this.sendError({id:s,topic:t,error:n}),this.client.logger.error(n)}},this.onSessionAuthenticateResponse=(t,e)=>{const{id:s}=e;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:t,payload:e}),g.isJsonRpcResult(e)?this.events.emit(i.engineEvent("session_request",s),{result:e.result}):g.isJsonRpcError(e)&&this.events.emit(i.engineEvent("session_request",s),{error:e.error})},this.onSessionAuthenticateRequest=async(t,e)=>{try{const{requester:s,authPayload:r,expiryTimestamp:n}=e.params,a=i.hashMessage(JSON.stringify(e)),c=await this.getVerifyContext(a,this.client.metadata),l={requester:s,pairingTopic:t,id:e.id,authPayload:r,verifyContext:c,expiryTimestamp:n};await this.setAuthRequest(e.id,{request:l,pairingTopic:t}),this.client.events.emit("session_authenticate",{topic:t,params:e.params,id:e.id,verifyContext:c})}catch(s){this.client.logger.error(s);const r=e.params.requester.publicKey,n=await this.client.core.crypto.generateKeyPair(),a={type:i.TYPE_1,receiverPublicKey:r,senderPublicKey:n};await this.sendError({id:e.id,topic:t,error:s,encodeOpts:a,rpcOpts:S.wc_sessionAuthenticate.autoReject})}},this.addSessionRequestToSessionRequestQueue=t=>{this.sessionRequestQueue.queue.push(t)},this.cleanupAfterResponse=t=>{this.deletePendingSessionRequest(t.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=A.idle,this.processSessionRequestQueue()},E.toMiliseconds(this.requestQueueDelay))},this.cleanupPendingSentRequestsForTopic=({topic:t,error:e})=>{const s=this.client.core.history.pending;s.length>0&&s.filter(r=>r.topic===t&&r.request.method==="wc_sessionRequest").forEach(r=>{const n=r.request.id,a=i.engineEvent("session_request",n);if(this.events.listenerCount(a)===0)throw new Error(`emitting ${a} without any listeners`);this.events.emit(i.engineEvent("session_request",r.request.id),{error:e})})},this.processSessionRequestQueue=()=>{if(this.sessionRequestQueue.state===A.active){this.client.logger.info("session request queue is already active.");return}const t=this.sessionRequestQueue.queue[0];if(!t){this.client.logger.info("session request queue is empty.");return}try{this.sessionRequestQueue.state=A.active,this.emitSessionRequest(t)}catch(e){this.client.logger.error(e)}},this.emitSessionRequest=t=>{this.client.events.emit("session_request",t)},this.onPairingCreated=t=>{if(t.methods&&this.expectedPairingMethodMap.set(t.topic,t.methods),t.active)return;const e=this.client.proposal.getAll().find(s=>s.pairingTopic===t.topic);e&&this.onSessionProposeRequest(t.topic,g.formatJsonRpcRequest("wc_sessionPropose",{requiredNamespaces:e.requiredNamespaces,optionalNamespaces:e.optionalNamespaces,relays:e.relays,proposer:e.proposer,sessionProperties:e.sessionProperties},e.id))},this.isValidConnect=async t=>{if(!i.isValidParams(t)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(t)}`);throw new Error(c)}const{pairingTopic:e,requiredNamespaces:s,optionalNamespaces:r,sessionProperties:n,relays:a}=t;if(i.isUndefined(e)||await this.isValidPairingTopic(e),!i.isValidRelays(a,!0)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`connect() relays: ${a}`);throw new Error(c)}!i.isUndefined(s)&&i.isValidObject(s)!==0&&this.validateNamespaces(s,"requiredNamespaces"),!i.isUndefined(r)&&i.isValidObject(r)!==0&&this.validateNamespaces(r,"optionalNamespaces"),i.isUndefined(n)||this.validateSessionProps(n,"sessionProperties")},this.validateNamespaces=(t,e)=>{const s=i.isValidRequiredNamespaces(t,"connect()",e);if(s)throw new Error(s.message)},this.isValidApprove=async t=>{if(!i.isValidParams(t))throw new Error(i.getInternalError("MISSING_OR_INVALID",`approve() params: ${t}`).message);const{id:e,namespaces:s,relayProtocol:r,sessionProperties:n}=t;this.checkRecentlyDeleted(e),await this.isValidProposalId(e);const a=this.client.proposal.get(e),c=i.isValidNamespaces(s,"approve()");if(c)throw new Error(c.message);const l=i.isConformingNamespaces(a.requiredNamespaces,s,"approve()");if(l)throw new Error(l.message);if(!i.isValidString(r,!0)){const{message:h}=i.getInternalError("MISSING_OR_INVALID",`approve() relayProtocol: ${r}`);throw new Error(h)}i.isUndefined(n)||this.validateSessionProps(n,"sessionProperties")},this.isValidReject=async t=>{if(!i.isValidParams(t)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`reject() params: ${t}`);throw new Error(r)}const{id:e,reason:s}=t;if(this.checkRecentlyDeleted(e),await this.isValidProposalId(e),!i.isValidErrorReason(s)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(s)}`);throw new Error(r)}},this.isValidSessionSettleRequest=t=>{if(!i.isValidParams(t)){const{message:l}=i.getInternalError("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${t}`);throw new Error(l)}const{relay:e,controller:s,namespaces:r,expiry:n}=t;if(!i.isValidRelay(e)){const{message:l}=i.getInternalError("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(l)}const a=i.isValidController(s,"onSessionSettleRequest()");if(a)throw new Error(a.message);const c=i.isValidNamespaces(r,"onSessionSettleRequest()");if(c)throw new Error(c.message);if(i.isExpired(n)){const{message:l}=i.getInternalError("EXPIRED","onSessionSettleRequest()");throw new Error(l)}},this.isValidUpdate=async t=>{if(!i.isValidParams(t)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`update() params: ${t}`);throw new Error(c)}const{topic:e,namespaces:s}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e);const r=this.client.session.get(e),n=i.isValidNamespaces(s,"update()");if(n)throw new Error(n.message);const a=i.isConformingNamespaces(r.requiredNamespaces,s,"update()");if(a)throw new Error(a.message)},this.isValidExtend=async t=>{if(!i.isValidParams(t)){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`extend() params: ${t}`);throw new Error(s)}const{topic:e}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e)},this.isValidRequest=async t=>{if(!i.isValidParams(t)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() params: ${t}`);throw new Error(c)}const{topic:e,request:s,chainId:r,expiry:n}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e);const{namespaces:a}=this.client.session.get(e);if(!i.isValidNamespacesChainId(a,r)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() chainId: ${r}`);throw new Error(c)}if(!i.isValidRequest(s)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() ${JSON.stringify(s)}`);throw new Error(c)}if(!i.isValidNamespacesRequest(a,r,s.method)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() method: ${s.method}`);throw new Error(c)}if(n&&!i.isValidRequestExpiry(n,Q)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() expiry: ${n}. Expiry must be a number (in seconds) between ${Q.min} and ${Q.max}`);throw new Error(c)}},this.isValidRespond=async t=>{var e;if(!i.isValidParams(t)){const{message:n}=i.getInternalError("MISSING_OR_INVALID",`respond() params: ${t}`);throw new Error(n)}const{topic:s,response:r}=t;try{await this.isValidSessionTopic(s)}catch(n){throw(e=t?.response)!=null&&e.id&&this.cleanupAfterResponse(t),n}if(!i.isValidResponse(r)){const{message:n}=i.getInternalError("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(r)}`);throw new Error(n)}},this.isValidPing=async t=>{if(!i.isValidParams(t)){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`ping() params: ${t}`);throw new Error(s)}const{topic:e}=t;await this.isValidSessionOrPairingTopic(e)},this.isValidEmit=async t=>{if(!i.isValidParams(t)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`emit() params: ${t}`);throw new Error(a)}const{topic:e,event:s,chainId:r}=t;await this.isValidSessionTopic(e);const{namespaces:n}=this.client.session.get(e);if(!i.isValidNamespacesChainId(n,r)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`emit() chainId: ${r}`);throw new Error(a)}if(!i.isValidEvent(s)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(a)}if(!i.isValidNamespacesEvent(n,r,s.name)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(a)}},this.isValidDisconnect=async t=>{if(!i.isValidParams(t)){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`disconnect() params: ${t}`);throw new Error(s)}const{topic:e}=t;await this.isValidSessionOrPairingTopic(e)},this.isValidAuthenticate=t=>{const{chains:e,uri:s,domain:r,nonce:n}=t;if(!Array.isArray(e)||e.length===0)throw new Error("chains is required and must be a non-empty array");if(!i.isValidString(s,!1))throw new Error("uri is required parameter");if(!i.isValidString(r,!1))throw new Error("domain is required parameter");if(!i.isValidString(n,!1))throw new Error("nonce is required parameter");if([...new Set(e.map(c=>i.parseChainId(c).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:a}=i.parseChainId(e[0]);if(a!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")},this.getVerifyContext=async(t,e)=>{const s={verified:{verifyUrl:e.verifyUrl||N.VERIFY_SERVER,validation:"UNKNOWN",origin:e.url||""}};try{const r=await this.client.core.verify.resolve({attestationId:t,verifyUrl:e.verifyUrl});r&&(s.verified.origin=r.origin,s.verified.isScam=r.isScam,s.verified.validation=r.origin===new URL(e.url).origin?"VALID":"INVALID")}catch(r){this.client.logger.info(r)}return this.client.logger.info(`Verify context: ${JSON.stringify(s)}`),s},this.validateSessionProps=(t,e)=>{Object.values(t).forEach(s=>{if(!i.isValidString(s,!1)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`${e} must be in Record<string, string> format. Received: ${JSON.stringify(s)}`);throw new Error(r)}})},this.getPendingAuthRequest=t=>{const e=this.client.auth.requests.get(t);return typeof e=="object"?e:void 0},this.addToRecentlyDeleted=(t,e)=>{if(this.recentlyDeletedMap.set(t,e),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let s=0;const r=this.recentlyDeletedLimit/2;for(const n of this.recentlyDeletedMap.keys()){if(s++>=r)break;this.recentlyDeletedMap.delete(n)}}},this.checkRecentlyDeleted=t=>{const e=this.recentlyDeletedMap.get(t);if(e){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`Record was recently deleted - ${e}: ${t}`);throw new Error(s)}}}async isInitialized(){if(!this.initialized){const{message:o}=i.getInternalError("NOT_INITIALIZED",this.name);throw new Error(o)}await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(N.RELAYER_EVENTS.message,o=>{!this.initialized||this.relayMessageCache.length>0?this.relayMessageCache.push(o):this.onRelayMessage(o)})}async onRelayMessage(o){const{topic:t,message:e}=o,{publicKey:s}=this.client.auth.authKeys.keys.includes($)?this.client.auth.authKeys.get($):{responseTopic:void 0,publicKey:void 0},r=await this.client.core.crypto.decode(t,e,{receiverPublicKey:s});try{g.isJsonRpcRequest(r)?(this.client.core.history.set(t,r),this.onRelayEventRequest({topic:t,payload:r})):g.isJsonRpcResponse(r)?(await this.client.core.history.resolve(r),await this.onRelayEventResponse({topic:t,payload:r}),this.client.core.history.delete(t,r.id)):this.onRelayEventUnknownPayload({topic:t,payload:r})}catch(n){this.client.logger.error(n)}}registerExpirerEvents(){this.client.core.expirer.on(N.EXPIRER_EVENTS.expired,async o=>{const{topic:t,id:e}=i.parseExpirerTarget(o.target);if(e&&this.client.pendingRequest.keys.includes(e))return await this.deletePendingSessionRequest(e,i.getInternalError("EXPIRED"),!0);if(e&&this.client.auth.requests.keys.includes(e))return await this.deletePendingAuthRequest(e,i.getInternalError("EXPIRED"),!0);t?this.client.session.keys.includes(t)&&(await this.deleteSession({topic:t,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:t})):e&&(await this.deleteProposal(e,!0),this.client.events.emit("proposal_expire",{id:e}))})}registerPairingEvents(){this.client.core.pairing.events.on(N.PAIRING_EVENTS.create,o=>this.onPairingCreated(o)),this.client.core.pairing.events.on(N.PAIRING_EVENTS.delete,o=>{this.addToRecentlyDeleted(o.topic,"pairing")})}isValidPairingTopic(o){if(!i.isValidString(o,!1)){const{message:t}=i.getInternalError("MISSING_OR_INVALID",`pairing topic should be a string: ${o}`);throw new Error(t)}if(!this.client.core.pairing.pairings.keys.includes(o)){const{message:t}=i.getInternalError("NO_MATCHING_KEY",`pairing topic doesn't exist: ${o}`);throw new Error(t)}if(i.isExpired(this.client.core.pairing.pairings.get(o).expiry)){const{message:t}=i.getInternalError("EXPIRED",`pairing topic: ${o}`);throw new Error(t)}}async isValidSessionTopic(o){if(!i.isValidString(o,!1)){const{message:t}=i.getInternalError("MISSING_OR_INVALID",`session topic should be a string: ${o}`);throw new Error(t)}if(this.checkRecentlyDeleted(o),!this.client.session.keys.includes(o)){const{message:t}=i.getInternalError("NO_MATCHING_KEY",`session topic doesn't exist: ${o}`);throw new Error(t)}if(i.isExpired(this.client.session.get(o).expiry)){await this.deleteSession({topic:o});const{message:t}=i.getInternalError("EXPIRED",`session topic: ${o}`);throw new Error(t)}if(!this.client.core.crypto.keychain.has(o)){const{message:t}=i.getInternalError("MISSING_OR_INVALID",`session topic does not exist in keychain: ${o}`);throw await this.deleteSession({topic:o}),new Error(t)}}async isValidSessionOrPairingTopic(o){if(this.checkRecentlyDeleted(o),this.client.session.keys.includes(o))await this.isValidSessionTopic(o);else if(this.client.core.pairing.pairings.keys.includes(o))this.isValidPairingTopic(o);else if(i.isValidString(o,!1)){const{message:t}=i.getInternalError("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${o}`);throw new Error(t)}else{const{message:t}=i.getInternalError("MISSING_OR_INVALID",`session or pairing topic should be a string: ${o}`);throw new Error(t)}}async isValidProposalId(o){if(!i.isValidId(o)){const{message:t}=i.getInternalError("MISSING_OR_INVALID",`proposal id should be a number: ${o}`);throw new Error(t)}if(!this.client.proposal.keys.includes(o)){const{message:t}=i.getInternalError("NO_MATCHING_KEY",`proposal id doesn't exist: ${o}`);throw new Error(t)}if(i.isExpired(this.client.proposal.get(o).expiryTimestamp)){await this.deleteProposal(o);const{message:t}=i.getInternalError("EXPIRED",`proposal id: ${o}`);throw new Error(t)}}}class Ke extends N.Store{constructor(o,t){super(o,t,le,j),this.core=o,this.logger=t}}class _e extends N.Store{constructor(o,t){super(o,t,pe,j),this.core=o,this.logger=t}}class Ge extends N.Store{constructor(o,t){super(o,t,ue,j,e=>e.id),this.core=o,this.logger=t}}class Fe extends N.Store{constructor(o,t){super(o,t,ye,U,()=>$),this.core=o,this.logger=t}}class ke extends N.Store{constructor(o,t){super(o,t,me,U),this.core=o,this.logger=t}}class je extends N.Store{constructor(o,t){super(o,t,Ie,U,e=>e.id),this.core=o,this.logger=t}}class Ye{constructor(o,t){this.core=o,this.logger=t,this.authKeys=new Fe(this.core,this.logger),this.pairingTopics=new ke(this.core,this.logger),this.requests=new je(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}class H extends ae.ISignClient{constructor(o){super(o),this.protocol=ee,this.version=te,this.name=Y.name,this.events=new ce.EventEmitter,this.on=(e,s)=>this.events.on(e,s),this.once=(e,s)=>this.events.once(e,s),this.off=(e,s)=>this.events.off(e,s),this.removeListener=(e,s)=>this.events.removeListener(e,s),this.removeAllListeners=e=>this.events.removeAllListeners(e),this.connect=async e=>{try{return await this.engine.connect(e)}catch(s){throw this.logger.error(s.message),s}},this.pair=async e=>{try{return await this.engine.pair(e)}catch(s){throw this.logger.error(s.message),s}},this.approve=async e=>{try{return await this.engine.approve(e)}catch(s){throw this.logger.error(s.message),s}},this.reject=async e=>{try{return await this.engine.reject(e)}catch(s){throw this.logger.error(s.message),s}},this.update=async e=>{try{return await this.engine.update(e)}catch(s){throw this.logger.error(s.message),s}},this.extend=async e=>{try{return await this.engine.extend(e)}catch(s){throw this.logger.error(s.message),s}},this.request=async e=>{try{return await this.engine.request(e)}catch(s){throw this.logger.error(s.message),s}},this.respond=async e=>{try{return await this.engine.respond(e)}catch(s){throw this.logger.error(s.message),s}},this.ping=async e=>{try{return await this.engine.ping(e)}catch(s){throw this.logger.error(s.message),s}},this.emit=async e=>{try{return await this.engine.emit(e)}catch(s){throw this.logger.error(s.message),s}},this.disconnect=async e=>{try{return await this.engine.disconnect(e)}catch(s){throw this.logger.error(s.message),s}},this.find=e=>{try{return this.engine.find(e)}catch(s){throw this.logger.error(s.message),s}},this.getPendingSessionRequests=()=>{try{return this.engine.getPendingSessionRequests()}catch(e){throw this.logger.error(e.message),e}},this.authenticate=async e=>{try{return await this.engine.authenticate(e)}catch(s){throw this.logger.error(s.message),s}},this.formatAuthMessage=e=>{try{return this.engine.formatAuthMessage(e)}catch(s){throw this.logger.error(s.message),s}},this.approveSessionAuthenticate=async e=>{try{return await this.engine.approveSessionAuthenticate(e)}catch(s){throw this.logger.error(s.message),s}},this.rejectSessionAuthenticate=async e=>{try{return await this.engine.rejectSessionAuthenticate(e)}catch(s){throw this.logger.error(s.message),s}},this.name=o?.name||Y.name,this.metadata=o?.metadata||i.getAppMetadata(),this.signConfig=o?.signConfig;const t=typeof o?.logger<"u"&&typeof o?.logger!="string"?o.logger:k.pino(k.getDefaultLoggerOptions({level:o?.logger||Y.logger}));this.core=o?.core||new N.Core(o),this.logger=k.generateChildLogger(t,this.name),this.session=new _e(this.core,this.logger),this.proposal=new Ke(this.core,this.logger),this.pendingRequest=new Ge(this.core,this.logger),this.engine=new $e(this),this.auth=new Ye(this.core,this.logger)}static async init(o){const t=new H(o);return await t.initialize(),t}get context(){return k.getLoggerContext(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.engine.init(),await this.auth.init(),this.core.verify.init({verifyUrl:this.metadata.verifyUrl}),this.logger.info("SignClient Initialization Success"),this.engine.processRelayMessageCache()}catch(o){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(o.message),o}}}const Qe=_e,He=H;exports.AUTH_CONTEXT=we,exports.AUTH_KEYS_CONTEXT=ye,exports.AUTH_PAIRING_TOPIC_CONTEXT=me,exports.AUTH_PROTOCOL=Ee,exports.AUTH_PUBLIC_KEY_NAME=$,exports.AUTH_REQUEST_CONTEXT=Ie,exports.AUTH_STORAGE_PREFIX=U,exports.AUTH_VERSION=De,exports.ENGINE_CONTEXT=de,exports.ENGINE_QUEUE_STATES=A,exports.ENGINE_RPC_OPTS=S,exports.HISTORY_CONTEXT=Ae,exports.HISTORY_EVENTS=Oe,exports.HISTORY_STORAGE_VERSION=Ve,exports.METHODS_TO_VERIFY=ge,exports.PROPOSAL_CONTEXT=le,exports.PROPOSAL_EXPIRY=Ce,exports.PROPOSAL_EXPIRY_MESSAGE=he,exports.REQUEST_CONTEXT=ue,exports.SESSION_CONTEXT=pe,exports.SESSION_EXPIRY=V,exports.SESSION_REQUEST_EXPIRY_BOUNDARIES=Q,exports.SIGN_CLIENT_CONTEXT=se,exports.SIGN_CLIENT_DEFAULT=Y,exports.SIGN_CLIENT_EVENTS=Te,exports.SIGN_CLIENT_PROTOCOL=ee,exports.SIGN_CLIENT_STORAGE_OPTIONS=Pe,exports.SIGN_CLIENT_STORAGE_PREFIX=j,exports.SIGN_CLIENT_VERSION=te,exports.SessionStore=Qe,exports.SignClient=He,exports.WALLETCONNECT_DEEPLINK_CHOICE=ie,exports.default=H;
//# sourceMappingURL=index.cjs.js.map
